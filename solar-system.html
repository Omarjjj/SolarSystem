<!--
    ============================================================================
    Solar System Simulation - Enhanced WebGL 3D Visualization
    ============================================================================
    
    Copyright (c) 2026
    
    Developed by:
        - Omar Jaber
        - Yazan Aydi
        - Mohammad Munir
    
    Features:
    - Elliptical orbits with eccentricity (Kepler's 1st Law)
    - Variable orbital speeds (Kepler's 2nd Law - faster near Sun)
    - Counter-clockwise prograde orbital motion
    - Planetary axial rotation with moons
    - Planetary ring systems (Jupiter, Saturn, Uranus, Neptune)
    - Galactic forward motion through space
    - 3D helical trajectory visualization
    - Realistic bloom lighting effects
    - Enhanced materials and atmospheres
    - Speed control system
    
    All rights reserved.
    ============================================================================
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System - Enhanced WebGL</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
        }
        #info h3 {
            margin: 0 0 10px 0;
            color: #ffd700;
        }
        #copyright {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 15px;
            border-radius: 8px;
            font-size: 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            text-align: right;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
        }
        #copyright h4 {
            margin: 0 0 8px 0;
            font-size: 13px;
            font-weight: bold;
            color: #ffd700;
        }
        #copyright p {
            margin: 3px 0;
            line-height: 1.4;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
            min-width: 200px;
        }
        #controls h4 {
            margin: 0 0 10px 0;
            color: #ffd700;
            font-size: 15px;
        }
        #speedSlider {
            width: 100%;
            margin: 10px 0;
            cursor: pointer;
        }
        #speedValue {
            color: #ffd700;
            font-weight: bold;
        }
        .control-group {
            margin: 8px 0;
        }
        .control-label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #ccc;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    
    <div id="info">
        <h3>üåå Realistic Solar System</h3>
        <p><strong>Controls:</strong></p>
        <p>üñ±Ô∏è Mouse: Rotate view</p>
        <p>üîÑ Scroll: Zoom in/out</p>
        <p>‚å®Ô∏è Arrow keys: Pan camera</p>
        <p><strong>Realistic Physics:</strong></p>
        <p>üîÑ Elliptical orbits (Kepler's 1st Law)</p>
        <p>‚ö° Variable speeds (Kepler's 2nd Law)</p>
        <p>üåç Counter-clockwise prograde motion</p>
        <p>üåô Natural satellites & moons</p>
        <p>üíç Planetary ring systems</p>
        <p>üöÄ Galactic motion (828,000 km/h)</p>
        <p>üí´ 3D helical trajectories</p>
    </div>
    
    <div id="controls">
        <h4>‚öôÔ∏è Animation Speed</h4>
        <div class="control-group">
            <label class="control-label">Speed Multiplier: <span id="speedValue">1.0x</span></label>
            <input type="range" id="speedSlider" min="0" max="300" value="100" step="1">
        </div>
        <div class="control-group">
            <label class="control-label">0.0x (Paused) ‚Üê ‚Üí 3.0x (Fast)</label>
        </div>
    </div>
    
    <div id="copyright">
        <h4>¬© 2026 Solar System WebGL</h4>
        <p>Developed by:</p>
        <p>Omar Jaber</p>
        <p>Yazan Aydi</p>
        <p>Mohammad Munir</p>
    </div>

    <!-- PLANET VERTEX SHADER -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec3 aPosition;
        attribute vec3 aNormal;
        
        uniform mat4 uModelMatrix;
        uniform mat4 uViewMatrix;
        uniform mat4 uProjectionMatrix;
        uniform mat4 uNormalMatrix;
        
        varying vec3 vNormal;
        varying vec3 vPosition;
        
        void main() {
            vec4 worldPosition = uModelMatrix * vec4(aPosition, 1.0);
            vPosition = worldPosition.xyz;
            vNormal = normalize((uNormalMatrix * vec4(aNormal, 0.0)).xyz);
            gl_Position = uProjectionMatrix * uViewMatrix * worldPosition;
        }
    </script>

    <!-- PLANET FRAGMENT SHADER with Enhanced Lighting -->
    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        
        uniform vec3 uColor;
        uniform vec3 uLightPosition;
        uniform bool uIsEmissive;
        uniform vec3 uCameraPosition;
        uniform float uGlow;
        
        varying vec3 vNormal;
        varying vec3 vPosition;
        
        void main() {
            if (uIsEmissive) {
                gl_FragColor = vec4(uColor * uGlow, 1.0);
            } else {
                vec3 normal = normalize(vNormal);
                vec3 lightDir = normalize(uLightPosition - vPosition);
                vec3 viewDir = normalize(uCameraPosition - vPosition);
                vec3 halfDir = normalize(lightDir + viewDir);
                
                vec3 ambient = 0.05 * uColor;
                
                float diff = max(dot(normal, lightDir), 0.0);
                vec3 diffuse = diff * uColor;
                
                float spec = pow(max(dot(normal, halfDir), 0.0), 64.0);
                vec3 specular = vec3(0.4) * spec;
                
                float rimFactor = 1.0 - max(dot(viewDir, normal), 0.0);
                rimFactor = pow(rimFactor, 3.0);
                vec3 rimLight = uColor * rimFactor * 0.3;
                
                float distance = length(uLightPosition - vPosition);
                float attenuation = 1.0 / (1.0 + 0.01 * distance + 0.001 * distance * distance);
                
                vec3 result = ambient + (diffuse + specular + rimLight) * attenuation;
                
                // Use uGlow for transparency (for rings) - if < 1.0, it's a ring
                float alpha = (uGlow < 1.0) ? uGlow : 1.0;
                gl_FragColor = vec4(result, alpha);
            }
        }
    </script>

    <!-- STAR VERTEX SHADER -->
    <script id="star-vertex-shader" type="x-shader/x-vertex">
        attribute vec3 aPosition;
        attribute float aSize;
        
        uniform mat4 uViewMatrix;
        uniform mat4 uProjectionMatrix;
        
        varying float vBrightness;
        
        void main() {
            vBrightness = aSize;
            gl_Position = uProjectionMatrix * uViewMatrix * vec4(aPosition, 1.0);
            gl_PointSize = aSize * 2.5;
        }
    </script>

    <!-- STAR FRAGMENT SHADER -->
    <script id="star-fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        
        varying float vBrightness;
        
        void main() {
            vec2 center = gl_PointCoord - vec2(0.5);
            float dist = length(center);
            if (dist > 0.5) discard;
            
            float intensity = (1.0 - dist * 2.0) * vBrightness;
            intensity = pow(intensity, 0.8);
            gl_FragColor = vec4(vec3(intensity), 1.0);
        }
    </script>

    <!-- BLOOM EXTRACT VERTEX SHADER -->
    <script id="bloom-vertex-shader" type="x-shader/x-vertex">
        attribute vec2 aPosition;
        varying vec2 vTexCoord;
        
        void main() {
            vTexCoord = aPosition * 0.5 + 0.5;
            gl_Position = vec4(aPosition, 0.0, 1.0);
        }
    </script>

    <!-- BLOOM EXTRACT FRAGMENT SHADER -->
    <script id="bloom-extract-shader" type="x-shader/x-fragment">
        precision mediump float;
        
        uniform sampler2D uTexture;
        uniform float uThreshold;
        
        varying vec2 vTexCoord;
        
        void main() {
            vec4 color = texture2D(uTexture, vTexCoord);
            float brightness = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));
            
            if (brightness > uThreshold) {
                gl_FragColor = color;
            } else {
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
            }
        }
    </script>

    <!-- BLOOM BLUR FRAGMENT SHADER -->
    <script id="bloom-blur-shader" type="x-shader/x-fragment">
        precision mediump float;
        
        uniform sampler2D uTexture;
        uniform vec2 uDirection;
        uniform vec2 uResolution;
        
        varying vec2 vTexCoord;
        
        void main() {
            vec2 texelSize = 1.0 / uResolution;
            vec4 result = vec4(0.0);
            
            float weights[5];
            weights[0] = 0.227027;
            weights[1] = 0.1945946;
            weights[2] = 0.1216216;
            weights[3] = 0.054054;
            weights[4] = 0.016216;
            
            result += texture2D(uTexture, vTexCoord) * weights[0];
            
            for (int i = 1; i < 5; i++) {
                vec2 offset = uDirection * texelSize * float(i);
                result += texture2D(uTexture, vTexCoord + offset) * weights[i];
                result += texture2D(uTexture, vTexCoord - offset) * weights[i];
            }
            
            gl_FragColor = result;
        }
    </script>

    <!-- BLOOM COMBINE FRAGMENT SHADER -->
    <script id="bloom-combine-shader" type="x-shader/x-fragment">
        precision mediump float;
        
        uniform sampler2D uScene;
        uniform sampler2D uBloom;
        uniform float uBloomIntensity;
        
        varying vec2 vTexCoord;
        
        void main() {
            vec4 sceneColor = texture2D(uScene, vTexCoord);
            vec4 bloomColor = texture2D(uBloom, vTexCoord);
            
            vec3 result = sceneColor.rgb + bloomColor.rgb * uBloomIntensity;
            result = result / (result + vec3(1.0));
            
            gl_FragColor = vec4(result, 1.0);
        }
    </script>

    <!-- TRAIL VERTEX SHADER -->
    <script id="trail-vertex-shader" type="x-shader/x-vertex">
        attribute vec3 aPosition;
        
        uniform mat4 uViewMatrix;
        uniform mat4 uProjectionMatrix;
        
        void main() {
            gl_Position = uProjectionMatrix * uViewMatrix * vec4(aPosition, 1.0);
        }
    </script>

    <!-- TRAIL FRAGMENT SHADER -->
    <script id="trail-fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        
        uniform vec4 uColor;
        
        void main() {
            gl_FragColor = uColor;
        }
    </script>

    <script>
        // ===== WebGL Initialization =====
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');
        
        if (!gl) {
            alert('WebGL not supported!');
        }

        const ext = gl.getExtension('OES_texture_float');
        
        // ===== Speed Control =====
        let speedMultiplier = 1.0;
        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');
        
        speedSlider.addEventListener('input', (e) => {
            speedMultiplier = e.target.value / 100;
            speedValue.textContent = speedMultiplier.toFixed(1) + 'x';
        });
        
        // Resize canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            createFramebuffers();
        }
        
        // ===== Shader Compilation =====
        function compileShader(gl, source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexSource, fragmentSource) {
            const vertexShader = compileShader(gl, vertexSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(gl, fragmentSource, gl.FRAGMENT_SHADER);
            
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        // Compile all shader programs
        const program = createProgram(gl, 
            document.getElementById('vertex-shader').textContent,
            document.getElementById('fragment-shader').textContent
        );
        
        const starProgram = createProgram(gl,
            document.getElementById('star-vertex-shader').textContent,
            document.getElementById('star-fragment-shader').textContent
        );
        
        const bloomExtractProgram = createProgram(gl,
            document.getElementById('bloom-vertex-shader').textContent,
            document.getElementById('bloom-extract-shader').textContent
        );
        
        const bloomBlurProgram = createProgram(gl,
            document.getElementById('bloom-vertex-shader').textContent,
            document.getElementById('bloom-blur-shader').textContent
        );
        
        const bloomCombineProgram = createProgram(gl,
            document.getElementById('bloom-vertex-shader').textContent,
            document.getElementById('bloom-combine-shader').textContent
        );
        
        const trailProgram = createProgram(gl,
            document.getElementById('trail-vertex-shader').textContent,
            document.getElementById('trail-fragment-shader').textContent
        );
        
        // Get attribute and uniform locations
        const attrs = {
            position: gl.getAttribLocation(program, 'aPosition'),
            normal: gl.getAttribLocation(program, 'aNormal'),
            starPosition: gl.getAttribLocation(starProgram, 'aPosition'),
            starSize: gl.getAttribLocation(starProgram, 'aSize')
        };
        
        const uniforms = {
            modelMatrix: gl.getUniformLocation(program, 'uModelMatrix'),
            viewMatrix: gl.getUniformLocation(program, 'uViewMatrix'),
            projectionMatrix: gl.getUniformLocation(program, 'uProjectionMatrix'),
            normalMatrix: gl.getUniformLocation(program, 'uNormalMatrix'),
            color: gl.getUniformLocation(program, 'uColor'),
            lightPosition: gl.getUniformLocation(program, 'uLightPosition'),
            isEmissive: gl.getUniformLocation(program, 'uIsEmissive'),
            cameraPosition: gl.getUniformLocation(program, 'uCameraPosition'),
            glow: gl.getUniformLocation(program, 'uGlow'),
            starView: gl.getUniformLocation(starProgram, 'uViewMatrix'),
            starProj: gl.getUniformLocation(starProgram, 'uProjectionMatrix')
        };

        // ===== Matrix Operations =====
        const mat4 = {
            create: () => new Float32Array(16),
            
            identity: (out) => {
                out[0] = 1; out[1] = 0; out[2] = 0; out[3] = 0;
                out[4] = 0; out[5] = 1; out[6] = 0; out[7] = 0;
                out[8] = 0; out[9] = 0; out[10] = 1; out[11] = 0;
                out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;
                return out;
            },
            
            perspective: (out, fovy, aspect, near, far) => {
                const f = 1.0 / Math.tan(fovy / 2);
                out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
                out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
                out[8] = 0; out[9] = 0; out[10] = (far + near) / (near - far); out[11] = -1;
                out[12] = 0; out[13] = 0; out[14] = (2 * far * near) / (near - far); out[15] = 0;
                return out;
            },
            
            lookAt: (out, eye, center, up) => {
                const z = [eye[0] - center[0], eye[1] - center[1], eye[2] - center[2]];
                const zLen = Math.sqrt(z[0] * z[0] + z[1] * z[1] + z[2] * z[2]);
                z[0] /= zLen; z[1] /= zLen; z[2] /= zLen;
                
                const x = [
                    up[1] * z[2] - up[2] * z[1],
                    up[2] * z[0] - up[0] * z[2],
                    up[0] * z[1] - up[1] * z[0]
                ];
                const xLen = Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);
                x[0] /= xLen; x[1] /= xLen; x[2] /= xLen;
                
                const y = [
                    z[1] * x[2] - z[2] * x[1],
                    z[2] * x[0] - z[0] * x[2],
                    z[0] * x[1] - z[1] * x[0]
                ];
                
                out[0] = x[0]; out[1] = y[0]; out[2] = z[0]; out[3] = 0;
                out[4] = x[1]; out[5] = y[1]; out[6] = z[1]; out[7] = 0;
                out[8] = x[2]; out[9] = y[2]; out[10] = z[2]; out[11] = 0;
                out[12] = -(x[0] * eye[0] + x[1] * eye[1] + x[2] * eye[2]);
                out[13] = -(y[0] * eye[0] + y[1] * eye[1] + y[2] * eye[2]);
                out[14] = -(z[0] * eye[0] + z[1] * eye[1] + z[2] * eye[2]);
                out[15] = 1;
                return out;
            },
            
            translate: (out, a, v) => {
                out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
                out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
                out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
                out[12] = a[0] * v[0] + a[4] * v[1] + a[8] * v[2] + a[12];
                out[13] = a[1] * v[0] + a[5] * v[1] + a[9] * v[2] + a[13];
                out[14] = a[2] * v[0] + a[6] * v[1] + a[10] * v[2] + a[14];
                out[15] = a[3] * v[0] + a[7] * v[1] + a[11] * v[2] + a[15];
                return out;
            },
            
            scale: (out, a, v) => {
                out[0] = a[0] * v[0]; out[1] = a[1] * v[0]; out[2] = a[2] * v[0]; out[3] = a[3] * v[0];
                out[4] = a[4] * v[1]; out[5] = a[5] * v[1]; out[6] = a[6] * v[1]; out[7] = a[7] * v[1];
                out[8] = a[8] * v[2]; out[9] = a[9] * v[2]; out[10] = a[10] * v[2]; out[11] = a[11] * v[2];
                out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
                return out;
            },
            
            rotateY: (out, a, rad) => {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                out[0] = a00 * c + a20 * s;
                out[1] = a01 * c + a21 * s;
                out[2] = a02 * c + a22 * s;
                out[3] = a03 * c + a23 * s;
                out[8] = a20 * c - a00 * s;
                out[9] = a21 * c - a01 * s;
                out[10] = a22 * c - a02 * s;
                out[11] = a23 * c - a03 * s;
                out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
                out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
                return out;
            },
            
            rotateZ: (out, a, rad) => {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                out[0] = a00 * c + a10 * s;
                out[1] = a01 * c + a11 * s;
                out[2] = a02 * c + a12 * s;
                out[3] = a03 * c + a13 * s;
                out[4] = a10 * c - a00 * s;
                out[5] = a11 * c - a01 * s;
                out[6] = a12 * c - a02 * s;
                out[7] = a13 * c - a03 * s;
                out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
                out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
                return out;
            },
            
            rotateX: (out, a, rad) => {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                out[4] = a10 * c + a20 * s;
                out[5] = a11 * c + a21 * s;
                out[6] = a12 * c + a22 * s;
                out[7] = a13 * c + a23 * s;
                out[8] = a20 * c - a10 * s;
                out[9] = a21 * c - a11 * s;
                out[10] = a22 * c - a12 * s;
                out[11] = a23 * c - a13 * s;
                out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
                out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
                return out;
            },
            
            invert: (out, a) => {
                const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
                
                const b00 = a00 * a11 - a01 * a10;
                const b01 = a00 * a12 - a02 * a10;
                const b02 = a00 * a13 - a03 * a10;
                const b03 = a01 * a12 - a02 * a11;
                const b04 = a01 * a13 - a03 * a11;
                const b05 = a02 * a13 - a03 * a12;
                const b06 = a20 * a31 - a21 * a30;
                const b07 = a20 * a32 - a22 * a30;
                const b08 = a20 * a33 - a23 * a30;
                const b09 = a21 * a32 - a22 * a31;
                const b10 = a21 * a33 - a23 * a31;
                const b11 = a22 * a33 - a23 * a32;
                
                let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                if (!det) return null;
                det = 1.0 / det;
                
                out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
                out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
                out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
                out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
                out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
                out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
                out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
                out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
                out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
                out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
                out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
                out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
                out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
                return out;
            },
            
            transpose: (out, a) => {
                if (out === a) {
                    const a01 = a[1], a02 = a[2], a03 = a[3];
                    const a12 = a[6], a13 = a[7];
                    const a23 = a[11];
                    out[1] = a[4]; out[2] = a[8]; out[3] = a[12];
                    out[4] = a01; out[6] = a[9]; out[7] = a[13];
                    out[8] = a02; out[9] = a12; out[11] = a[14];
                    out[12] = a03; out[13] = a13; out[14] = a23;
                } else {
                    out[0] = a[0]; out[1] = a[4]; out[2] = a[8]; out[3] = a[12];
                    out[4] = a[1]; out[5] = a[5]; out[6] = a[9]; out[7] = a[13];
                    out[8] = a[2]; out[9] = a[6]; out[10] = a[10]; out[11] = a[14];
                    out[12] = a[3]; out[13] = a[7]; out[14] = a[11]; out[15] = a[15];
                }
                return out;
            }
        };

        // ===== Geometry Generation =====
        function createSphere(radius, latBands, longBands) {
            const vertices = [];
            const normals = [];
            const indices = [];
            
            for (let lat = 0; lat <= latBands; lat++) {
                const theta = lat * Math.PI / latBands;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);
                
                for (let long = 0; long <= longBands; long++) {
                    const phi = long * 2 * Math.PI / longBands;
                    const sinPhi = Math.sin(phi);
                    const cosPhi = Math.cos(phi);
                    
                    const x = cosPhi * sinTheta;
                    const y = cosTheta;
                    const z = sinPhi * sinTheta;
                    
                    normals.push(x, y, z);
                    vertices.push(radius * x, radius * y, radius * z);
                }
            }
            
            for (let lat = 0; lat < latBands; lat++) {
                for (let long = 0; long < longBands; long++) {
                    const first = lat * (longBands + 1) + long;
                    const second = first + longBands + 1;
                    
                    indices.push(first, second, first + 1);
                    indices.push(second, second + 1, first + 1);
                }
            }
            
            return { vertices, normals, indices };
        }

        // ===== Ring Geometry Generation =====
        // Creates a flat ring (disk with hole in center)
        function createRing(innerRadius, outerRadius, segments) {
            const vertices = [];
            const normals = [];
            const indices = [];
            
            // Create ring vertices
            for (let i = 0; i <= segments; i++) {
                const theta = (i / segments) * Math.PI * 2;
                const cos = Math.cos(theta);
                const sin = Math.sin(theta);
                
                // Inner vertex
                vertices.push(innerRadius * cos, 0, innerRadius * sin);
                normals.push(0, 1, 0); // Normal points up
                
                // Outer vertex
                vertices.push(outerRadius * cos, 0, outerRadius * sin);
                normals.push(0, 1, 0);
            }
            
            // Create indices for triangles
            for (let i = 0; i < segments; i++) {
                const base = i * 2;
                // First triangle
                indices.push(base, base + 2, base + 1);
                // Second triangle
                indices.push(base + 1, base + 2, base + 3);
            }
            
            return { vertices, normals, indices };
        }

        // Create sphere buffers
        const sphere = createSphere(1, 40, 40);
        
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphere.vertices), gl.STATIC_DRAW);
        
        const normalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphere.normals), gl.STATIC_DRAW);
        
        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(sphere.indices), gl.STATIC_DRAW);

        // Create ring buffers
        const ring = createRing(1.2, 2.0, 64);
        
        const ringPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, ringPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(ring.vertices), gl.STATIC_DRAW);
        
        const ringNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, ringNormalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(ring.normals), gl.STATIC_DRAW);
        
        const ringIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ringIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(ring.indices), gl.STATIC_DRAW);

        // ===== Star Generation =====
        function generateStars(count) {
            const positions = [];
            const sizes = [];
            
            for (let i = 0; i < count; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                const radius = 150 + Math.random() * 450;
                
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);
                
                positions.push(x, y, z);
                sizes.push(0.3 + Math.random() * 2.0);
            }
            
            return { positions, sizes };
        }
        
        const stars = generateStars(3000);
        
        const starPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, starPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(stars.positions), gl.STATIC_DRAW);
        
        const starSizeBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, starSizeBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(stars.sizes), gl.STATIC_DRAW);

        // ===== Enhanced Planet Data with Realistic Orbital Mechanics =====
        // Elliptical orbits with eccentricity (0 = circle, closer to 1 = more elliptical)
        const planets = [
            { 
                name: 'Sun', radius: 3.5, semiMajorAxis: 0, orbitSpeed: 0, rotationSpeed: 0.005,
                eccentricity: 0, // Sun doesn't orbit
                color: [1.0, 0.9, 0.2], emissive: true, glow: 2.5,
                moons: []
            },
            { 
                name: 'Mercury', radius: 0.38, semiMajorAxis: 6, orbitSpeed: 4.15, rotationSpeed: 0.002,
                eccentricity: 0.206, // Most eccentric orbit
                color: [0.7, 0.7, 0.7], emissive: false, glow: 1.0,
                moons: []
            },
            { 
                name: 'Venus', radius: 0.95, semiMajorAxis: 8, orbitSpeed: 1.62, rotationSpeed: 0.0005,
                eccentricity: 0.007, // Nearly circular
                color: [0.9, 0.75, 0.5], emissive: false, glow: 1.0,
                moons: []
            },
            { 
                name: 'Earth', radius: 1.0, semiMajorAxis: 11, orbitSpeed: 1.0, rotationSpeed: 0.05,
                eccentricity: 0.017, // Slightly elliptical
                color: [0.1, 0.4, 0.8], emissive: false, glow: 1.0,
                moons: [
                    { name: 'Moon', radius: 0.27, distance: 2.2, orbitSpeed: 2.0, color: [0.8, 0.8, 0.75] }
                ]
            },
            { 
                name: 'Mars', radius: 0.53, semiMajorAxis: 14, orbitSpeed: 0.53, rotationSpeed: 0.048,
                eccentricity: 0.093, // Moderately elliptical
                color: [0.9, 0.3, 0.2], emissive: false, glow: 1.0,
                moons: [
                    { name: 'Phobos', radius: 0.12, distance: 1.3, orbitSpeed: 5.0, color: [0.6, 0.6, 0.5] },
                    { name: 'Deimos', radius: 0.08, distance: 1.8, orbitSpeed: 3.5, color: [0.65, 0.65, 0.55] }
                ]
            },
            { 
                name: 'Jupiter', radius: 2.5, semiMajorAxis: 20, orbitSpeed: 0.08, rotationSpeed: 0.12,
                eccentricity: 0.049, // Slightly elliptical
                color: [0.85, 0.65, 0.45], emissive: false, glow: 1.0,
                rings: { 
                    innerRadius: 2.8, 
                    outerRadius: 3.2, 
                    color: [0.6, 0.5, 0.4], 
                    opacity: 0.15,
                    tilt: 0.05
                },
                moons: [
                    { name: 'Io', radius: 0.25, distance: 3.8, orbitSpeed: 3.2, color: [0.9, 0.85, 0.3] },
                    { name: 'Europa', radius: 0.22, distance: 4.5, orbitSpeed: 2.8, color: [0.9, 0.9, 0.85] },
                    { name: 'Ganymede', radius: 0.32, distance: 5.2, orbitSpeed: 2.2, color: [0.7, 0.6, 0.5] },
                    { name: 'Callisto', radius: 0.28, distance: 6.0, orbitSpeed: 1.8, color: [0.5, 0.5, 0.45] }
                ]
            },
            { 
                name: 'Saturn', radius: 2.1, semiMajorAxis: 27, orbitSpeed: 0.03, rotationSpeed: 0.11,
                eccentricity: 0.056, // Slightly elliptical
                color: [0.95, 0.85, 0.65], emissive: false, glow: 1.0,
                rings: { 
                    innerRadius: 2.8, 
                    outerRadius: 4.5, 
                    color: [0.9, 0.85, 0.75], 
                    opacity: 0.7,
                    tilt: 0.15
                },
                moons: [
                    { name: 'Titan', radius: 0.35, distance: 4.5, orbitSpeed: 2.0, color: [0.85, 0.75, 0.6] },
                    { name: 'Rhea', radius: 0.15, distance: 3.5, orbitSpeed: 2.8, color: [0.85, 0.85, 0.8] },
                    { name: 'Iapetus', radius: 0.12, distance: 5.5, orbitSpeed: 1.5, color: [0.7, 0.7, 0.65] }
                ]
            },
            { 
                name: 'Uranus', radius: 1.4, semiMajorAxis: 33, orbitSpeed: 0.01, rotationSpeed: 0.07,
                eccentricity: 0.046, // Slightly elliptical
                color: [0.4, 0.75, 0.85], emissive: false, glow: 1.0,
                rings: { 
                    innerRadius: 1.8, 
                    outerRadius: 2.5, 
                    color: [0.3, 0.35, 0.4], 
                    opacity: 0.25,
                    tilt: 1.57
                },
                moons: [
                    { name: 'Titania', radius: 0.18, distance: 3.0, orbitSpeed: 2.5, color: [0.75, 0.75, 0.7] },
                    { name: 'Oberon', radius: 0.16, distance: 3.8, orbitSpeed: 2.0, color: [0.7, 0.7, 0.68] }
                ]
            },
            { 
                name: 'Neptune', radius: 1.3, semiMajorAxis: 39, orbitSpeed: 0.006, rotationSpeed: 0.075,
                eccentricity: 0.009, // Nearly circular
                color: [0.2, 0.3, 0.9], emissive: false, glow: 1.0,
                rings: { 
                    innerRadius: 1.7, 
                    outerRadius: 2.3, 
                    color: [0.4, 0.45, 0.55], 
                    opacity: 0.2,
                    tilt: 0.08
                },
                moons: [
                    { name: 'Triton', radius: 0.22, distance: 3.2, orbitSpeed: -2.8, color: [0.8, 0.8, 0.85] }
                ]
            }
        ];

        // ===== Framebuffer Setup for Bloom =====
        let framebuffers = {};
        
        function createFramebuffers() {
            const width = canvas.width;
            const height = canvas.height;
            
            framebuffers.scene = createFramebuffer(width, height);
            framebuffers.bright = createFramebuffer(width / 2, height / 2);
            framebuffers.blur1 = createFramebuffer(width / 2, height / 2);
            framebuffers.blur2 = createFramebuffer(width / 2, height / 2);
        }
        
        function createFramebuffer(width, height) {
            const framebuffer = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            
            const renderbuffer = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
            
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            
            return { framebuffer, texture, width, height };
        }
        
        // Fullscreen quad for post-processing
        const quadBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

        // ===== Camera Controls =====
        let cameraDistance = 55;
        let cameraAngleX = 0.4;
        let cameraAngleY = 0;
        let cameraOffsetX = 0;
        let cameraOffsetY = 0;
        
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                
                cameraAngleY += deltaX * 0.01;
                cameraAngleX += deltaY * 0.01;
                cameraAngleX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraAngleX));
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            cameraDistance += e.deltaY * 0.05;
            cameraDistance = Math.max(15, Math.min(200, cameraDistance));
        });

        window.addEventListener('keydown', (e) => {
            const panSpeed = 0.5;
            switch(e.key) {
                case 'ArrowLeft': cameraOffsetX -= panSpeed; break;
                case 'ArrowRight': cameraOffsetX += panSpeed; break;
                case 'ArrowUp': cameraOffsetY += panSpeed; break;
                case 'ArrowDown': cameraOffsetY -= panSpeed; break;
            }
        });

        // ===== Rendering Functions =====
        function renderQuad(program) {
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            const posLoc = gl.getAttribLocation(program, 'aPosition');
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

        function renderCelestialBody(modelMatrix, color, isEmissive, glow) {
            const normalMatrix = mat4.create();
            mat4.invert(normalMatrix, modelMatrix);
            mat4.transpose(normalMatrix, normalMatrix);
            
            gl.uniformMatrix4fv(uniforms.modelMatrix, false, modelMatrix);
            gl.uniformMatrix4fv(uniforms.normalMatrix, false, normalMatrix);
            gl.uniform3fv(uniforms.color, color);
            gl.uniform1i(uniforms.isEmissive, isEmissive);
            gl.uniform1f(uniforms.glow, glow);
            
            gl.drawElements(gl.TRIANGLES, sphere.indices.length, gl.UNSIGNED_SHORT, 0);
        }

        function renderScene(viewMatrix, projectionMatrix, galacticOffset, time) {
            // ===== RENDER ORBITAL TRAILS =====
            gl.useProgram(trailProgram);
            gl.lineWidth(2.0);
            
            // Enable blending for transparent trails
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            
            const trailViewLoc = gl.getUniformLocation(trailProgram, 'uViewMatrix');
            const trailProjLoc = gl.getUniformLocation(trailProgram, 'uProjectionMatrix');
            const trailColorLoc = gl.getUniformLocation(trailProgram, 'uColor');
            const trailPosLoc = gl.getAttribLocation(trailProgram, 'aPosition');
            
            gl.uniformMatrix4fv(trailViewLoc, false, viewMatrix);
            gl.uniformMatrix4fv(trailProjLoc, false, projectionMatrix);
            
            // Draw trails for each planet
            planets.forEach((planet, idx) => {
                if (planet.semiMajorAxis === 0) return; // Skip Sun
                
                const trail = trailHistory.get(idx);
                if (trail && trail.length > 1) {
                    const trailBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, trailBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(trail.flat()), gl.DYNAMIC_DRAW);
                    
                    gl.enableVertexAttribArray(trailPosLoc);
                    gl.vertexAttribPointer(trailPosLoc, 3, gl.FLOAT, false, 0, 0);
                    
                    // Blue-ish trail color with transparency based on planet color
                    const alpha = 0.4;
                    gl.uniform4f(trailColorLoc, 
                        planet.color[0] * 0.5 + 0.2, 
                        planet.color[1] * 0.5 + 0.3, 
                        planet.color[2] * 0.5 + 0.8, 
                        alpha);
                    
                    gl.drawArrays(gl.LINE_STRIP, 0, trail.length);
                    gl.deleteBuffer(trailBuffer);
                }
            });
            
            // ===== RENDER PLANETS =====
            gl.disable(gl.BLEND); // Disable blending for solid planets
            gl.useProgram(program);
            
            // Bind planet buffers
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(attrs.position);
            gl.vertexAttribPointer(attrs.position, 3, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.enableVertexAttribArray(attrs.normal);
            gl.vertexAttribPointer(attrs.normal, 3, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            
            // Send matrices
            gl.uniformMatrix4fv(uniforms.viewMatrix, false, viewMatrix);
            gl.uniformMatrix4fv(uniforms.projectionMatrix, false, projectionMatrix);
            gl.uniform3f(uniforms.lightPosition, galacticOffset[0], galacticOffset[1], galacticOffset[2]);
            
            const cameraX = cameraOffsetX + cameraDistance * Math.cos(cameraAngleX) * Math.sin(cameraAngleY);
            const cameraY = cameraOffsetY + cameraDistance * Math.sin(cameraAngleX);
            const cameraZ = cameraDistance * Math.cos(cameraAngleX) * Math.cos(cameraAngleY);
            gl.uniform3f(uniforms.cameraPosition, cameraX, cameraY, cameraZ);
            
            // Render planets and their moons
            planets.forEach((planet, idx) => {
                const modelMatrix = mat4.create();
                mat4.identity(modelMatrix);
                
                // Apply galactic motion
                mat4.translate(modelMatrix, modelMatrix, galacticOffset);
                
                // Elliptical orbital position using Kepler's laws
                let planetX = 0, planetZ = 0;
                if (planet.semiMajorAxis > 0) {
                    // Mean anomaly (angle progresses uniformly with time)
                    const meanAnomaly = time * planet.orbitSpeed;
                    
                    // Solve Kepler's equation for eccentric anomaly (simplified approximation)
                    // E = M + e*sin(M) for small eccentricities
                    const e = planet.eccentricity;
                    let E = meanAnomaly + e * Math.sin(meanAnomaly);
                    
                    // True anomaly (actual angle from perihelion)
                    const trueAnomaly = 2 * Math.atan2(
                        Math.sqrt(1 + e) * Math.sin(E / 2),
                        Math.sqrt(1 - e) * Math.cos(E / 2)
                    );
                    
                    // Distance from Sun (varies with position in orbit)
                    const a = planet.semiMajorAxis;
                    const r = a * (1 - e * e) / (1 + e * Math.cos(trueAnomaly));
                    
                    // Counter-clockwise elliptical orbit (prograde motion)
                    planetX = r * Math.cos(trueAnomaly);
                    planetZ = r * Math.sin(trueAnomaly);
                    
                    mat4.translate(modelMatrix, modelMatrix, [planetX, 0, planetZ]);
                }
                
                // Store planet position for moons AND trail recording
                const planetPosition = [
                    galacticOffset[0] + planetX,
                    galacticOffset[1],
                    galacticOffset[2] + planetZ
                ];
                
                // Record trail position (helical elliptical path)
                if (planet.semiMajorAxis > 0) {
                    const trail = trailHistory.get(idx);
                    trail.push([...planetPosition]);
                    
                    // Keep trail length manageable
                    if (trail.length > maxTrailLength) {
                        trail.shift();
                    }
                }
                
                // Planetary rotation (spin on axis)
                const rotationAngle = time * planet.rotationSpeed;
                mat4.rotateY(modelMatrix, modelMatrix, rotationAngle);
                
                // Scale
                mat4.scale(modelMatrix, modelMatrix, [planet.radius, planet.radius, planet.radius]);
                
                // Render planet
                renderCelestialBody(modelMatrix, planet.color, planet.emissive, planet.glow);
                
                // Render planetary rings if they exist
                if (planet.rings) {
                    // Enable blending for semi-transparent rings
                    gl.enable(gl.BLEND);
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                    
                    // Switch to ring buffers
                    gl.bindBuffer(gl.ARRAY_BUFFER, ringPositionBuffer);
                    gl.enableVertexAttribArray(attrs.position);
                    gl.vertexAttribPointer(attrs.position, 3, gl.FLOAT, false, 0, 0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, ringNormalBuffer);
                    gl.enableVertexAttribArray(attrs.normal);
                    gl.vertexAttribPointer(attrs.normal, 3, gl.FLOAT, false, 0, 0);
                    
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ringIndexBuffer);
                    
                    // Create ring transformation matrix
                    const ringMatrix = mat4.create();
                    mat4.identity(ringMatrix);
                    
                    // Position at planet location (using same elliptical calculation)
                    mat4.translate(ringMatrix, ringMatrix, galacticOffset);
                    if (planet.semiMajorAxis > 0) {
                        const meanAnomaly = time * planet.orbitSpeed;
                        const e = planet.eccentricity;
                        let E = meanAnomaly + e * Math.sin(meanAnomaly);
                        const trueAnomaly = 2 * Math.atan2(
                            Math.sqrt(1 + e) * Math.sin(E / 2),
                            Math.sqrt(1 - e) * Math.cos(E / 2)
                        );
                        const a = planet.semiMajorAxis;
                        const r = a * (1 - e * e) / (1 + e * Math.cos(trueAnomaly));
                        const x = r * Math.cos(trueAnomaly);
                        const z = r * Math.sin(trueAnomaly);
                        mat4.translate(ringMatrix, ringMatrix, [x, 0, z]);
                    }
                    
                    // Tilt the ring
                    mat4.rotateX(ringMatrix, ringMatrix, planet.rings.tilt);
                    
                    // Rotate with planet
                    mat4.rotateY(ringMatrix, ringMatrix, time * planet.rotationSpeed);
                    
                    // Scale ring
                    const ringScale = planet.radius * (planet.rings.outerRadius / 2.0);
                    mat4.scale(ringMatrix, ringMatrix, [ringScale, ringScale, ringScale]);
                    
                    // Calculate normal matrix for ring
                    const ringNormalMatrix = mat4.create();
                    mat4.invert(ringNormalMatrix, ringMatrix);
                    mat4.transpose(ringNormalMatrix, ringNormalMatrix);
                    
                    // Set uniforms for ring
                    gl.uniformMatrix4fv(uniforms.modelMatrix, false, ringMatrix);
                    gl.uniformMatrix4fv(uniforms.normalMatrix, false, ringNormalMatrix);
                    
                    // Ring color with transparency
                    const ringColor = [...planet.rings.color];
                    gl.uniform3fv(uniforms.color, ringColor);
                    gl.uniform1i(uniforms.isEmissive, false);
                    gl.uniform1f(uniforms.glow, planet.rings.opacity);
                    
                    // Draw ring
                    gl.drawElements(gl.TRIANGLES, ring.indices.length, gl.UNSIGNED_SHORT, 0);
                    
                    // Disable blending and restore planet buffers
                    gl.disable(gl.BLEND);
                    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                    gl.enableVertexAttribArray(attrs.position);
                    gl.vertexAttribPointer(attrs.position, 3, gl.FLOAT, false, 0, 0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                    gl.enableVertexAttribArray(attrs.normal);
                    gl.vertexAttribPointer(attrs.normal, 3, gl.FLOAT, false, 0, 0);
                    
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                }
                
                // Render moons
                planet.moons.forEach(moon => {
                    const moonMatrix = mat4.create();
                    mat4.identity(moonMatrix);
                    
                    // Position relative to planet
                    mat4.translate(moonMatrix, moonMatrix, planetPosition);
                    
                    // Moon orbital position around planet
                    const moonAngle = time * moon.orbitSpeed;
                    const moonX = moon.distance * Math.cos(moonAngle);
                    const moonZ = moon.distance * Math.sin(moonAngle);
                    mat4.translate(moonMatrix, moonMatrix, [moonX, 0, moonZ]);
                    
                    // Moon rotation
                    mat4.rotateY(moonMatrix, moonMatrix, moonAngle);
                    
                    // Scale
                    mat4.scale(moonMatrix, moonMatrix, [moon.radius, moon.radius, moon.radius]);
                    
                    // Render moon
                    renderCelestialBody(moonMatrix, moon.color, false, 1.0);
                });
            });
        }

        // ===== Orbital Trail System =====
        const trailHistory = new Map(); // Store trail positions for each planet
        const maxTrailLength = 200; // Number of trail points
        
        // Initialize trails for each planet
        planets.forEach((planet, idx) => {
            trailHistory.set(idx, []);
        });
        
        // ===== Main Render Loop =====
        let time = 0;
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        function render() {
            // Apply speed multiplier to time increment
            time += 0.01 * speedMultiplier;
            
            // Forward motion through space - solar system moves along Z-axis
            const forwardMotion = time * 3.0; // Move forward continuously
            const galacticOffset = [
                0, // No X drift
                0, // No Y drift  
                forwardMotion // Forward along Z
            ];
            
            // Camera setup - follow the solar system's forward motion
            const cameraX = cameraOffsetX + cameraDistance * Math.cos(cameraAngleX) * Math.sin(cameraAngleY);
            const cameraY = cameraOffsetY + cameraDistance * Math.sin(cameraAngleX);
            const cameraZ = forwardMotion + cameraDistance * Math.cos(cameraAngleX) * Math.cos(cameraAngleY);
            
            const viewMatrix = mat4.create();
            // Camera looks at the center of the solar system which is also moving forward
            mat4.lookAt(viewMatrix, 
                [cameraX, cameraY, cameraZ], 
                [cameraOffsetX, cameraOffsetY, forwardMotion], 
                [0, 1, 0]);
            
            const projectionMatrix = mat4.create();
            mat4.perspective(projectionMatrix, Math.PI / 4, canvas.width / canvas.height, 0.1, 1000);
            
            // ===== RENDER TO SCENE FRAMEBUFFER =====
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers.scene.framebuffer);
            gl.viewport(0, 0, framebuffers.scene.width, framebuffers.scene.height);
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            
            // Render stars
            gl.useProgram(starProgram);
            gl.disable(gl.DEPTH_TEST);
            
            gl.uniformMatrix4fv(uniforms.starView, false, viewMatrix);
            gl.uniformMatrix4fv(uniforms.starProj, false, projectionMatrix);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, starPositionBuffer);
            gl.enableVertexAttribArray(attrs.starPosition);
            gl.vertexAttribPointer(attrs.starPosition, 3, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, starSizeBuffer);
            gl.enableVertexAttribArray(attrs.starSize);
            gl.vertexAttribPointer(attrs.starSize, 1, gl.FLOAT, false, 0, 0);
            
            gl.drawArrays(gl.POINTS, 0, stars.positions.length / 3);
            
            // Render planets and moons
            gl.enable(gl.DEPTH_TEST);
            renderScene(viewMatrix, projectionMatrix, galacticOffset, time);
            
            // ===== BLOOM POST-PROCESSING =====
            gl.disable(gl.DEPTH_TEST);
            
            // Extract bright areas
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers.bright.framebuffer);
            gl.viewport(0, 0, framebuffers.bright.width, framebuffers.bright.height);
            gl.useProgram(bloomExtractProgram);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, framebuffers.scene.texture);
            gl.uniform1i(gl.getUniformLocation(bloomExtractProgram, 'uTexture'), 0);
            gl.uniform1f(gl.getUniformLocation(bloomExtractProgram, 'uThreshold'), 0.7);
            renderQuad(bloomExtractProgram);
            
            // Blur horizontally
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers.blur1.framebuffer);
            gl.useProgram(bloomBlurProgram);
            gl.bindTexture(gl.TEXTURE_2D, framebuffers.bright.texture);
            gl.uniform1i(gl.getUniformLocation(bloomBlurProgram, 'uTexture'), 0);
            gl.uniform2f(gl.getUniformLocation(bloomBlurProgram, 'uDirection'), 1.0, 0.0);
            gl.uniform2f(gl.getUniformLocation(bloomBlurProgram, 'uResolution'), 
                framebuffers.blur1.width, framebuffers.blur1.height);
            renderQuad(bloomBlurProgram);
            
            // Blur vertically
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers.blur2.framebuffer);
            gl.bindTexture(gl.TEXTURE_2D, framebuffers.blur1.texture);
            gl.uniform2f(gl.getUniformLocation(bloomBlurProgram, 'uDirection'), 0.0, 1.0);
            renderQuad(bloomBlurProgram);
            
            // Combine scene + bloom
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.useProgram(bloomCombineProgram);
            
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, framebuffers.scene.texture);
            gl.uniform1i(gl.getUniformLocation(bloomCombineProgram, 'uScene'), 0);
            
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, framebuffers.blur2.texture);
            gl.uniform1i(gl.getUniformLocation(bloomCombineProgram, 'uBloom'), 1);
            gl.uniform1f(gl.getUniformLocation(bloomCombineProgram, 'uBloomIntensity'), 1.2);
            
            renderQuad(bloomCombineProgram);
            
            requestAnimationFrame(render);
        }
        
        render();
    </script>
</body>
</html>
